// ======================================================
// Stage 3: Compute C = Ar * tmpJ
// ======================================================
@kernel void TensorProductVolumeStage3(const int M,
                                       const int N,
                                       const int K,
                                       @restrict const double *Ar,
                                       @restrict const double *tmpJ,
                                       @restrict double *C,
                                       const int LDC,
                                       const int totalWork,
                                       const int offsetA,
                                       const int offsetC,
                                       const int addToC) {

  for(int l=0; l < N; l++; @outer) {
    for(int k=0; k < M; k++;@inner) {
      for(int j=0; j < M; j++;@inner) {
	for(int i=0; i< M; i++;@inner) {

	  // Access slices
	  const double *tJ = tmpJ + l * (M * K * MPad);
	  double *c = C + l * LDC + offsetC;
	  const int offC = M * (j + k * M);
	  double accum;
	  accum=0;
	  // Multiply-accumulate in r-direction
#pragma omp simd
	  for (int ii = 0; ii < K; ++ii) {
	    const int offA = ii * MPad + offsetA;
	    const int indJ = MPad * (ii + k * K) + j;
	    accum += Ar[offA + i] * tJ[indJ];
	  }
	  // Write or add to C
	  if (addToC) {
	    c[offC + i] += accum;
	  } else {
	    c[offC + i] = accum;
	  }
	}
      }
    }
  }
}
